# Shell functions generator
#
# Converts Fish functions to bash/zsh functions.
# These functions implement the git helpers that are called by aliases.
{ config, lib, pkgs, ... }:

let
  functionsFile = pkgs.writeText "shell-functions.sh" ''
    # Generated shell functions from Fish functions
    # DO NOT EDIT - Generated by nix/modules/home/shell-functions.nix
    # Generated at build time from Fish functions

    # Git utility functions

    git-get-default-branch() {
      local remote="$1"
      if [ -z "$remote" ]; then
        return 1
      fi
      git rev-parse --abbrev-ref "$remote/HEAD" | sed "s#$remote/##"
    }

    git-get-first-remote() {
      local remotes
      remotes=$(git remote)
      if echo "$remotes" | grep -q '^upstream$'; then
        echo upstream
      elif echo "$remotes" | grep -q '^origin$'; then
        echo origin
      else
        echo "$remotes" | head -n1
      fi
    }

    git-checkout-default() {
      local remote
      local default_branch
      remote=$(git-get-first-remote)
      default_branch=$(git-get-default-branch "$remote")
      git checkout "$default_branch"
    }

    git-checkout-default-fetch() {
      git-checkout-default && git fetch --all --prune
    }

    git-checkout-default-fetch-fast-forward() {
      git-checkout-default-fetch && git pull --ff-only
    }

    git-diff-head() {
      git diff HEAD
    }

    git-diff-head-pbcopy() {
      git diff HEAD | pbcopy
    }

    git-diff-head-files-pbcopy() {
      git diff HEAD --name-only | pbcopy
    }

    # Git push functions - origin-first (set-upstream)

    git-push-origin-first() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)"
    }

    git-push-origin-first-force() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)" --force
    }

    git-push-origin-first-force-with-lease() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)" --force-with-lease
    }

    git-push-origin-first-no-verify() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify
    }

    git-push-origin-first-no-verify-force() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force
    }

    git-push-origin-first-no-verify-force-with-lease() {
      git push --set-upstream origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force-with-lease
    }

    # Git push functions - origin (no set-upstream)

    git-push-origin() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)"
    }

    git-push-origin-force() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)" --force
    }

    git-push-origin-force-with-lease() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)" --force-with-lease
    }

    git-push-origin-no-verify() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify
    }

    git-push-origin-no-verify-force() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force
    }

    git-push-origin-no-verify-force-with-lease() {
      git push origin "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force-with-lease
    }

    # Git push functions - upstream-first (set-upstream)

    git-push-upstream-first() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)"
    }

    git-push-upstream-first-force() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)" --force
    }

    git-push-upstream-first-force-with-lease() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)" --force-with-lease
    }

    git-push-upstream-first-no-verify() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify
    }

    git-push-upstream-first-no-verify-force() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force
    }

    git-push-upstream-first-no-verify-force-with-lease() {
      git push --set-upstream upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force-with-lease
    }

    # Git push functions - upstream (no set-upstream)

    git-push-upstream() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)"
    }

    git-push-upstream-force() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)" --force
    }

    git-push-upstream-force-with-lease() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)" --force-with-lease
    }

    git-push-upstream-no-verify() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify
    }

    git-push-upstream-no-verify-force() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force
    }

    git-push-upstream-no-verify-force-with-lease() {
      git push upstream "$(git rev-parse --abbrev-ref HEAD)" --no-verify --force-with-lease
    }

    # Git clean branches

    git_clean_branches() {
      git branch --merged | grep -v '\*\|main\|master' | xargs -n 1 git branch -d
    }

    # Git clone to projects

    git_clone_to_projects() {
      if [ -z "$PROJECTS_PATH" ]; then
        echo "Variable \$PROJECTS_PATH is not defined" >&2
        return 1
      fi

      local repo_url="$1"
      local regex='s/^git@github\.com:(.+)\/(.+)\.git$/\1 \2/'
      local names=$(echo "$repo_url" | sed -E "$regex")

      if [ $(echo "$names" | wc -w) -ne 2 ]; then
        echo "Invalid or unsupported repository path ($repo_url)" >&2
        return 121
      fi

      local org_name=$(echo "$names" | awk '{print $1}')
      local repo_name=$(echo "$names" | awk '{print $2}')
      local org_path="$PROJECTS_PATH/$org_name"
      local full_path="$org_path/$repo_name"

      if [ -e "$full_path" ]; then
        echo "Directory \"$full_path\" already exists" >&2
        return 121
      fi

      mkdir -p "$full_path" && \
      git clone "$repo_url" "$full_path" && \
      export __LAST_CLONED_REPO_PATH="$full_path"
    }
  '';

in
{
  # Create the functions file in the config directory
  home.file.".config/shell/functions.sh".source = functionsFile;
}
